# MosesQuantæ¡†æ¶å…¬å…±ç»„ä»¶ä¸å¯æ’æ‹”ç»„ä»¶è®¾è®¡

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
> **åˆ›å»ºæ—¥æœŸ**: 2025-07-18  
> **è®¾è®¡ç›®æ ‡**: æ˜ç¡®åŒºåˆ†æ¡†æ¶æ ¸å¿ƒä¸ç”¨æˆ·æ‰©å±•è¾¹ç•Œï¼Œç¡®ä¿æ¶æ„çš„ç¨³å®šæ€§å’Œå¯æ‰©å±•æ€§

## 1. è®¾è®¡ç†å¿µï¼šæ¸…æ™°çš„è¾¹ç•Œåˆ’åˆ†

### 1.1 æ ¸å¿ƒè®¾è®¡åŸåˆ™

```mermaid
graph TD
    subgraph "å…¬å…±æ ¸å¿ƒå±‚ (Framework Core)"
        A1[ç±»å‹ç³»ç»Ÿ Types]
        A2[äº‹ä»¶æ€»çº¿ EventBus]
        A3[å†…å­˜ç®¡ç† Memory]
        A4[é…ç½®ç³»ç»Ÿ Config]
        A5[é”™è¯¯å¤„ç† Error]
    end
    
    subgraph "å¯æ’æ‹”æ¥å£å±‚ (Plugin Interfaces)"
        B1[Strategy Trait]
        B2[Gateway Trait]
        B3[DataSource Trait]
        B4[RiskModel Trait]
        B5[LabelGenerator Trait]
    end
    
    subgraph "ç”¨æˆ·å®ç°å±‚ (User Extensions)"
        C1[å…·ä½“ç­–ç•¥å®ç°]
        C2[äº¤æ˜“æ‰€è¿æ¥å™¨]
        C3[æ•°æ®æºå®ç°]
        C4[é£é™©æ¨¡å‹å®ç°]
        C5[æŠ€æœ¯åˆ†ææ¨¡å—]
    end
    
    A1 --> B1
    A2 --> B2
    A3 --> B3
    A4 --> B4
    A5 --> B5
    
    B1 --> C1
    B2 --> C2
    B3 --> C3
    B4 --> C4
    B5 --> C5
```

**æ ¸å¿ƒåŸåˆ™**ï¼š
1. **å…¬å…±æ ¸å¿ƒç¨³å®šä¸å˜** - æä¾›åŸºç¡€è®¾æ–½ï¼Œç¡®ä¿ç‰ˆæœ¬å…¼å®¹æ€§
2. **æ’æ‹”æ¥å£æ ‡å‡†åŒ–** - é€šè¿‡Rust traitå®šä¹‰æ¸…æ™°çš„æ‰©å±•ç‚¹
3. **ç”¨æˆ·å®ç°è‡ªç”±** - åœ¨æ ‡å‡†æ¥å£çº¦æŸä¸‹ï¼Œç”¨æˆ·å¯å®Œå…¨è‡ªå®šä¹‰å®ç°
4. **é›¶è¿è¡Œæ—¶å¼€é”€** - ä½¿ç”¨ç¼–è¯‘æ—¶å¤šæ€ï¼Œé¿å…åŠ¨æ€åˆ†å‘æ€§èƒ½æŸå¤±

## 2. å…¬å…±æ ¸å¿ƒç»„ä»¶ï¼ˆFramework Coreï¼‰

### 2.1 æ ¸å¿ƒç±»å‹ç³»ç»Ÿ

```rust
// ================================
// å…¬å…±æ ¸å¿ƒï¼šåŸºç¡€æ•°æ®ç»“æ„
// ä½ç½®ï¼šsrc/types.rs
// ç‰¹ç‚¹ï¼šæ¡†æ¶åŸºç¡€ï¼Œç”¨æˆ·ä¸å¯ä¿®æ”¹ï¼Œåªèƒ½ä½¿ç”¨
// ================================

/// æ ¸å¿ƒä»·æ ¼ç±»å‹ - ä¿è¯ç²¾åº¦å’Œä¸€è‡´æ€§
pub type Price = rust_decimal::Decimal;
pub type Quantity = rust_decimal::Decimal;
pub type TimestampNs = i64;

/// åŸºç¡€å¸‚åœºæ•°æ® - æ‰€æœ‰æ•°æ®æºå¿…é¡»è½¬æ¢ä¸ºæ­¤æ ¼å¼
#[derive(Debug, Clone, PartialEq)]
pub struct Bar {
    pub symbol: Symbol,
    pub timestamp: TimestampNs,
    pub open: Price,
    pub high: Price,
    pub low: Price,
    pub close: Price,
    pub volume: Quantity,
    pub turnover: Option<Price>,
    pub trade_count: Option<u32>,
}

#[derive(Debug, Clone, PartialEq)]
pub struct Tick {
    pub symbol: Symbol,
    pub timestamp: TimestampNs,
    pub price: Price,
    pub size: Quantity,
    pub side: Side,
    pub trade_id: Option<String>,
}

/// è®¢å•æ ¸å¿ƒç»“æ„ - ç»Ÿä¸€çš„è®¢å•è¡¨ç¤º
#[derive(Debug, Clone, PartialEq)]
pub struct Order {
    pub id: OrderId,
    pub symbol: Symbol,
    pub side: Side,
    pub order_type: OrderType,
    pub quantity: Quantity,
    pub price: Option<Price>,
    pub status: OrderStatus,
    pub created_at: TimestampNs,
    pub updated_at: TimestampNs,
    pub filled_quantity: Quantity,
    pub average_fill_price: Option<Price>,
    pub commission: Price,
    pub metadata: HashMap<String, Value>,
}

/// æŒä»“æ ¸å¿ƒç»“æ„
#[derive(Debug, Clone, PartialEq)]
pub struct Position {
    pub symbol: Symbol,
    pub quantity: Quantity,  // æ­£æ•°ä¸ºå¤šå¤´ï¼Œè´Ÿæ•°ä¸ºç©ºå¤´
    pub average_price: Price,
    pub market_value: Price,
    pub unrealized_pnl: Price,
    pub realized_pnl: Price,
    pub last_updated: TimestampNs,
}

/// æ ¸å¿ƒæšä¸¾ - æ¡†æ¶æ ‡å‡†ï¼Œä¸å¯å˜æ›´
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum Side {
    Buy,
    Sell,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum OrderType {
    Market,
    Limit,
    Stop,
    StopLimit,
    TrailingStop,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum OrderStatus {
    Pending,
    Submitted,
    PartiallyFilled,
    Filled,
    Cancelled,
    Rejected,
    Expired,
}

/// ç»Ÿä¸€ç»“æœç±»å‹ - æ¡†æ¶çº§é”™è¯¯å¤„ç†
pub type Result<T> = std::result::Result<T, CzscError>;
```

### 2.2 äº‹ä»¶ç³»ç»Ÿæ ¸å¿ƒ

```rust
// ================================
// å…¬å…±æ ¸å¿ƒï¼šäº‹ä»¶æ€»çº¿ç³»ç»Ÿ
// ä½ç½®ï¼šsrc/events.rs
// ç‰¹ç‚¹ï¼šæä¾›ç»Ÿä¸€çš„äº‹ä»¶è°ƒåº¦åŸºç¡€è®¾æ–½
// ================================

/// äº‹ä»¶æ€»çº¿ - æ¡†æ¶æ ¸å¿ƒï¼Œç”¨æˆ·ä¸å¯æ›¿æ¢
pub struct EventBus {
    // ä½¿ç”¨channelå®ç°é«˜æ€§èƒ½å¼‚æ­¥äº‹ä»¶ä¼ é€’
    event_sender: tokio::sync::mpsc::UnboundedSender<BoxedEvent>,
    event_receiver: Arc<Mutex<tokio::sync::mpsc::UnboundedReceiver<BoxedEvent>>>,
    
    // äº‹ä»¶å¤„ç†å™¨æ³¨å†Œè¡¨
    handlers: Arc<RwLock<HashMap<TypeId, Vec<BoxedEventHandler>>>>,
    
    // è·¯ç”±ç­–ç•¥ï¼ˆå…¬å…±é…ç½®ï¼‰
    routing_strategy: EventRoutingStrategy,
    
    // æ€§èƒ½ç»Ÿè®¡ï¼ˆå…¬å…±ç›‘æ§ï¼‰
    stats: Arc<RwLock<EventBusStatistics>>,
}

/// äº‹ä»¶ç‰¹å¾ - ç”¨æˆ·å¯å®ç°ï¼Œä½†å¿…é¡»éµå¾ªæ­¤æ¥å£
pub trait Event: Send + Sync + Debug + 'static {
    fn event_type(&self) -> &'static str;
    fn timestamp(&self) -> TimestampNs;
    fn priority(&self) -> EventPriority;
    fn source(&self) -> &str;
}

/// äº‹ä»¶å¤„ç†å™¨ç‰¹å¾ - ç”¨æˆ·å¯æ’æ‹”å®ç°ç‚¹
#[async_trait]
pub trait EventHandler<T: Event>: Send + Sync {
    async fn handle(&self, event: &T) -> Result<()>;
    fn handler_id(&self) -> &str;
    fn can_handle_parallel(&self) -> bool { true }
}

/// äº‹ä»¶ä¼˜å…ˆçº§ - æ¡†æ¶çº§åˆ«å®šä¹‰
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum EventPriority {
    Critical = 0,    // è®¢å•æ‰§è¡Œã€é£é™©æ§åˆ¶
    High = 1,        // å¸‚åœºæ•°æ®æ›´æ–°
    Normal = 2,      // ç­–ç•¥ä¿¡å·
    Low = 3,         // æ—¥å¿—ã€ç»Ÿè®¡
}

impl EventBus {
    /// æ³¨å†Œäº‹ä»¶å¤„ç†å™¨ - ç”¨æˆ·æ‰©å±•ç‚¹
    pub fn register_handler<T: Event>(
        &mut self,
        handler: Box<dyn EventHandler<T>>
    ) -> Result<()> {
        let type_id = TypeId::of::<T>();
        let boxed_handler = Box::new(move |event: &dyn Event| {
            if let Some(typed_event) = event.downcast_ref::<T>() {
                handler.handle(typed_event)
            } else {
                Box::pin(async { Ok(()) })
            }
        });
        
        let mut handlers = self.handlers.write().await;
        handlers.entry(type_id).or_insert_with(Vec::new).push(boxed_handler);
        
        Ok(())
    }
    
    /// å‘å¸ƒäº‹ä»¶ - å…¬å…±APIï¼Œæ€§èƒ½ä¼˜åŒ–
    pub async fn publish<T: Event>(&self, event: T) -> Result<()> {
        // æ€§èƒ½ä¼˜åŒ–ï¼šé¿å…ä¸å¿…è¦çš„åºåˆ—åŒ–
        let boxed_event = Box::new(event) as BoxedEvent;
        
        // å¼‚æ­¥å‘é€ï¼Œé¿å…é˜»å¡
        self.event_sender.send(boxed_event)
            .map_err(|_| CzscError::EventBusError("Failed to send event".to_string()))?;
        
        // æ›´æ–°ç»Ÿè®¡
        self.stats.write().await.events_published += 1;
        
        Ok(())
    }
}
```

### 2.3 å†…å­˜ç®¡ç†æ ¸å¿ƒ

```rust
// ================================
// å…¬å…±æ ¸å¿ƒï¼šå†…å­˜ç®¡ç†ç³»ç»Ÿ
// ä½ç½®ï¼šsrc/memory.rs
// ç‰¹ç‚¹ï¼šé›¶æˆæœ¬æŠ½è±¡ï¼Œé«˜æ€§èƒ½å†…å­˜æ± 
// ================================

/// å¯¹è±¡æ±  - å‡å°‘åŠ¨æ€åˆ†é…ï¼Œæå‡æ€§èƒ½
pub struct ObjectPool<T> {
    pool: Arc<Mutex<Vec<T>>>,
    factory: fn() -> T,
    max_size: usize,
    created_count: AtomicUsize,
    recycled_count: AtomicUsize,
}

impl<T> ObjectPool<T> {
    pub fn new(factory: fn() -> T, max_size: usize) -> Self {
        Self {
            pool: Arc::new(Mutex::new(Vec::with_capacity(max_size))),
            factory,
            max_size,
            created_count: AtomicUsize::new(0),
            recycled_count: AtomicUsize::new(0),
        }
    }
    
    /// è·å–å¯¹è±¡ - è‡ªåŠ¨ç®¡ç†ç”Ÿå‘½å‘¨æœŸ
    pub fn acquire(&self) -> PooledObject<T> {
        let object = {
            let mut pool = self.pool.lock().unwrap();
            if let Some(obj) = pool.pop() {
                self.recycled_count.fetch_add(1, Ordering::Relaxed);
                obj
            } else {
                self.created_count.fetch_add(1, Ordering::Relaxed);
                (self.factory)()
            }
        };
        
        PooledObject {
            object: Some(object),
            pool: Arc::clone(&self.pool),
            max_size: self.max_size,
        }
    }
}

/// æ± åŒ–å¯¹è±¡ - RAIIè‡ªåŠ¨å½’è¿˜
pub struct PooledObject<T> {
    object: Option<T>,
    pool: Arc<Mutex<Vec<T>>>,
    max_size: usize,
}

impl<T> Drop for PooledObject<T> {
    fn drop(&mut self) {
        if let Some(object) = self.object.take() {
            let mut pool = self.pool.lock().unwrap();
            if pool.len() < self.max_size {
                pool.push(object);
            }
        }
    }
}

/// å…¨å±€å†…å­˜æ± ç®¡ç†å™¨
pub struct MemoryManager {
    order_pool: ObjectPool<Order>,
    bar_pool: ObjectPool<Bar>,
    tick_pool: ObjectPool<Tick>,
    position_pool: ObjectPool<Position>,
}

// å…¨å±€å•ä¾‹ï¼Œæ¡†æ¶çº§åˆ«ç®¡ç†
lazy_static! {
    pub static ref MEMORY_MANAGER: MemoryManager = MemoryManager::new();
}
```

### 2.4 é…ç½®ç³»ç»Ÿæ ¸å¿ƒ

```rust
// ================================
// å…¬å…±æ ¸å¿ƒï¼šé…ç½®ç®¡ç†ç³»ç»Ÿ
// ä½ç½®ï¼šsrc/config.rs
// ç‰¹ç‚¹ï¼šç±»å‹å®‰å…¨çš„é…ç½®è§£æå’ŒéªŒè¯
// ================================

/// æ¡†æ¶é…ç½® - æ ¸å¿ƒæ¡†æ¶è¡Œä¸ºé…ç½®
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FrameworkConfig {
    pub name: String,
    pub version: String,
    pub timezone: String,
    pub initial_capital: Price,
    
    // äº‹ä»¶ç³»ç»Ÿé…ç½®
    pub event_bus: EventBusConfig,
    
    // å†…å­˜ç®¡ç†é…ç½®
    pub memory: MemoryConfig,
    
    // æ—¥å¿—é…ç½®
    pub logging: LoggingConfig,
    
    // æ€§èƒ½ç›‘æ§é…ç½®
    pub monitoring: MonitoringConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EventBusConfig {
    pub buffer_size: usize,
    pub max_parallel_handlers: usize,
    pub routing_strategy: EventRoutingStrategy,
}

/// é…ç½®åŠ è½½å™¨ - æ”¯æŒå¤šç§é…ç½®æº
pub struct ConfigLoader {
    config_paths: Vec<PathBuf>,
    environment_prefix: String,
    validation_rules: Vec<Box<dyn ConfigValidator>>,
}

impl ConfigLoader {
    /// åŠ è½½å’ŒéªŒè¯é…ç½®
    pub fn load<T: DeserializeOwned + ConfigValidate>(&self) -> Result<T> {
        // 1. ä»æ–‡ä»¶åŠ è½½åŸºç¡€é…ç½®
        let mut config_value = self.load_from_files()?;
        
        // 2. ç¯å¢ƒå˜é‡è¦†ç›–
        self.apply_environment_variables(&mut config_value)?;
        
        // 3. ååºåˆ—åŒ–ä¸ºå¼ºç±»å‹
        let config: T = serde_yaml::from_value(config_value)?;
        
        // 4. é…ç½®éªŒè¯
        config.validate()?;
        
        Ok(config)
    }
}

/// é…ç½®éªŒè¯ç‰¹å¾ - ç¼–è¯‘æ—¶ç±»å‹å®‰å…¨
pub trait ConfigValidate {
    fn validate(&self) -> Result<()>;
}
```

## 3. å¯æ’æ‹”æ¥å£å±‚ï¼ˆPlugin Interfacesï¼‰

### 3.1 ç­–ç•¥æ¥å£

```rust
// ================================
// å¯æ’æ‹”æ¥å£ï¼šç­–ç•¥ç³»ç»Ÿ
// ä½ç½®ï¼šsrc/strategy/traits.rs
// ç‰¹ç‚¹ï¼šç”¨æˆ·å¿…é¡»å®ç°ï¼Œæ¡†æ¶æä¾›é»˜è®¤å®ç°
// ================================

/// ç­–ç•¥ç‰¹å¾ - ç”¨æˆ·ä¸»è¦æ‰©å±•ç‚¹
#[async_trait]
pub trait Strategy: Send + Sync {
    // === å¿…é¡»å®ç°çš„æ ¸å¿ƒæ–¹æ³• ===
    async fn on_start(&mut self, context: &StrategyContext) -> Result<()>;
    async fn on_data(&mut self, context: &StrategyContext, data: &MarketData) -> Result<Vec<Order>>;
    async fn on_order(&mut self, context: &StrategyContext, order: &Order) -> Result<()>;
    async fn on_trade(&mut self, context: &StrategyContext, trade: &Trade) -> Result<()>;
    async fn on_stop(&mut self, context: &StrategyContext) -> Result<()>;
    
    // === å…ƒä¿¡æ¯æ–¹æ³•ï¼ˆå¿…é¡»å®ç°ï¼‰===
    fn strategy_id(&self) -> &str;
    fn strategy_name(&self) -> &str;
    fn version(&self) -> &str;
    
    // === å¯é€‰å®ç°çš„é«˜çº§æ–¹æ³• ===
    async fn on_timer(&mut self, _context: &StrategyContext, _timer_id: &str) -> Result<()> {
        Ok(()) // é»˜è®¤ç©ºå®ç°
    }
    
    async fn on_error(&mut self, _context: &StrategyContext, _error: &CzscError) -> Result<()> {
        Ok(()) // é»˜è®¤ç©ºå®ç°
    }
    
    fn supported_symbols(&self) -> Vec<Symbol> {
        vec![] // é»˜è®¤æ”¯æŒæ‰€æœ‰
    }
    
    fn required_data_types(&self) -> Vec<DataType> {
        vec![DataType::Bar] // é»˜è®¤éœ€è¦Baræ•°æ®
    }
}

/// äº”é˜¶æ®µç­–ç•¥ç‰¹å¾ - å¯é€‰çš„é«˜çº§æ¥å£
#[async_trait]
pub trait PipelineStrategy: Strategy {
    async fn universe_selection(&self, context: &StrategyContext) -> Result<Vec<Symbol>>;
    async fn alpha_generation(&self, context: &StrategyContext, universe: &[Symbol]) -> Result<Vec<Insight>>;
    async fn portfolio_construction(&self, context: &StrategyContext, insights: &[Insight]) -> Result<Vec<PortfolioTarget>>;
    async fn risk_management(&self, context: &StrategyContext, targets: &[PortfolioTarget]) -> Result<Vec<PortfolioTarget>>;
    async fn execution(&self, context: &StrategyContext, targets: &[PortfolioTarget]) -> Result<Vec<Order>>;
}

/// ç­–ç•¥ä¸Šä¸‹æ–‡ - æ¡†æ¶æä¾›ï¼Œç”¨æˆ·æ¶ˆè´¹
pub struct StrategyContext {
    // æ¡†æ¶æ ¸å¿ƒæœåŠ¡ï¼ˆåªè¯»è®¿é—®ï¼‰
    pub strategy_id: String,
    pub current_time: TimestampNs,
    pub portfolio: Arc<RwLock<Portfolio>>,
    pub data_manager: Arc<dyn DataManager>,
    pub order_manager: Arc<dyn OrderManager>,
    pub risk_manager: Arc<dyn RiskManager>,
    
    // ç”¨æˆ·å¯è®¿é—®çš„å·¥å…·
    pub logger: Arc<dyn Logger>,
    pub metrics: Arc<dyn MetricsCollector>,
    pub cache: Arc<dyn Cache>,
}

impl StrategyContext {
    /// è·å–å†å²æ•°æ® - ç»Ÿä¸€API
    pub async fn get_bars(&self, symbol: &Symbol, count: usize) -> Result<Vec<Bar>> {
        self.data_manager.get_bars(symbol, count).await
    }
    
    /// æäº¤è®¢å• - ç»Ÿä¸€API
    pub async fn submit_order(&self, order: Order) -> Result<OrderId> {
        self.order_manager.submit_order(order).await
    }
    
    /// è®°å½•æ—¥å¿— - ç»Ÿä¸€API
    pub fn log(&self, level: LogLevel, message: &str) {
        self.logger.log(level, &self.strategy_id, message);
    }
}
```

### 3.2 æ•°æ®æºæ¥å£

```rust
// ================================
// å¯æ’æ‹”æ¥å£ï¼šæ•°æ®æºç³»ç»Ÿ
// ä½ç½®ï¼šsrc/data/traits.rs
// ç‰¹ç‚¹ï¼šç”¨æˆ·å®ç°å…·ä½“æ•°æ®æºï¼Œæ¡†æ¶æä¾›è°ƒåº¦
// ================================

/// æ•°æ®æºç‰¹å¾ - ç”¨æˆ·æ‰©å±•ç‚¹
#[async_trait]
pub trait DataSource: Send + Sync {
    // === å¿…é¡»å®ç°çš„æ ¸å¿ƒæ–¹æ³• ===
    async fn connect(&mut self) -> Result<()>;
    async fn disconnect(&mut self) -> Result<()>;
    async fn subscribe(&mut self, symbols: Vec<Symbol>, data_types: Vec<DataType>) -> Result<()>;
    async fn get_historical_data(&self, request: DataRequest) -> Result<Vec<Bar>>;
    
    // === å…ƒä¿¡æ¯æ–¹æ³• ===
    fn source_id(&self) -> &str;
    fn source_type(&self) -> DataSourceType;
    fn supported_symbols(&self) -> Vec<Symbol>;
    fn supported_data_types(&self) -> Vec<DataType>;
    
    // === å¯é€‰æ–¹æ³• ===
    async fn unsubscribe(&mut self, _symbols: Vec<Symbol>) -> Result<()> {
        Ok(()) // é»˜è®¤ç©ºå®ç°
    }
    
    fn is_real_time(&self) -> bool { true }
    fn latency_estimate(&self) -> Duration { Duration::from_millis(100) }
    
    // === å¥åº·æ£€æŸ¥ ===
    async fn health_check(&self) -> Result<DataSourceHealth> {
        Ok(DataSourceHealth::Healthy) // é»˜è®¤å¥åº·
    }
}

/// æ•°æ®æºç±»å‹æšä¸¾ - æ¡†æ¶å®šä¹‰
#[derive(Debug, Clone, PartialEq)]
pub enum DataSourceType {
    RealTime,      // å®æ—¶æ•°æ®æº
    Historical,    // å†å²æ•°æ®æº
    Simulated,     // æ¨¡æ‹Ÿæ•°æ®æº
    Hybrid,        // æ··åˆæ•°æ®æº
}

/// æ•°æ®è¯·æ±‚ - ç»Ÿä¸€çš„æ•°æ®æŸ¥è¯¢æ ¼å¼
#[derive(Debug, Clone)]
pub struct DataRequest {
    pub symbol: Symbol,
    pub data_type: DataType,
    pub start_time: Option<TimestampNs>,
    pub end_time: Option<TimestampNs>,
    pub limit: Option<usize>,
    pub resolution: Option<Duration>,
}

/// æ•°æ®ç®¡ç†å™¨ç‰¹å¾ - æ¡†æ¶æä¾›çš„æ•°æ®æœåŠ¡æ¥å£
#[async_trait]
pub trait DataManager: Send + Sync {
    // ç”¨æˆ·é€šè¿‡ç­–ç•¥ä¸Šä¸‹æ–‡è°ƒç”¨è¿™äº›æ–¹æ³•
    async fn get_bars(&self, symbol: &Symbol, count: usize) -> Result<Vec<Bar>>;
    async fn get_ticks(&self, symbol: &Symbol, count: usize) -> Result<Vec<Tick>>;
    async fn get_latest_price(&self, symbol: &Symbol) -> Result<Price>;
    
    // æ•°æ®æºç®¡ç†ï¼ˆå†…éƒ¨æ–¹æ³•ï¼‰
    async fn register_data_source(&mut self, source: Box<dyn DataSource>) -> Result<()>;
    async fn start_data_feeds(&mut self) -> Result<()>;
    async fn stop_data_feeds(&mut self) -> Result<()>;
}
```

### 3.3 ç½‘å…³æ¥å£

```rust
// ================================
// å¯æ’æ‹”æ¥å£ï¼šäº¤æ˜“ç½‘å…³ç³»ç»Ÿ
// ä½ç½®ï¼šsrc/gateway/traits.rs
// ç‰¹ç‚¹ï¼šç”¨æˆ·å®ç°å…·ä½“äº¤æ˜“æ‰€æ¥å£
// ================================

/// äº¤æ˜“ç½‘å…³ç‰¹å¾ - ç”¨æˆ·æ‰©å±•ç‚¹
#[async_trait]
pub trait Gateway: Send + Sync {
    // === è¿æ¥ç®¡ç† ===
    async fn connect(&mut self) -> Result<()>;
    async fn disconnect(&mut self) -> Result<()>;
    fn is_connected(&self) -> bool;
    
    // === è®¢å•ç®¡ç† ===
    async fn submit_order(&mut self, order: Order) -> Result<OrderResponse>;
    async fn cancel_order(&mut self, order_id: &OrderId) -> Result<()>;
    async fn get_order_status(&self, order_id: &OrderId) -> Result<OrderStatus>;
    
    // === è´¦æˆ·æŸ¥è¯¢ ===
    async fn get_account_info(&self) -> Result<AccountInfo>;
    async fn get_positions(&self) -> Result<Vec<Position>>;
    async fn get_balance(&self) -> Result<Balance>;
    
    // === å…ƒä¿¡æ¯ ===
    fn gateway_id(&self) -> &str;
    fn gateway_type(&self) -> GatewayType;
    fn supported_order_types(&self) -> Vec<OrderType>;
    fn fee_structure(&self) -> FeeStructure;
    
    // === å¯é€‰åŠŸèƒ½ ===
    async fn modify_order(&mut self, _order_id: &OrderId, _modification: OrderModification) -> Result<()> {
        Err(CzscError::NotSupported("Order modification not supported".to_string()))
    }
    
    async fn batch_submit_orders(&mut self, orders: Vec<Order>) -> Result<Vec<OrderResponse>> {
        // é»˜è®¤å®ç°ï¼šé€ä¸ªæäº¤
        let mut responses = Vec::new();
        for order in orders {
            responses.push(self.submit_order(order).await?);
        }
        Ok(responses)
    }
}

/// ç½‘å…³ç±»å‹ - æ¡†æ¶é¢„å®šä¹‰ + ç”¨æˆ·æ‰©å±•
#[derive(Debug, Clone, PartialEq)]
pub enum GatewayType {
    // æ¡†æ¶é¢„å®šä¹‰
    Simulated,
    
    // ç”¨æˆ·å¯æ·»åŠ æ–°ç±»å‹
    Binance,
    Coinbase,
    InteractiveBrokers,
    
    // è‡ªå®šä¹‰ç½‘å…³
    Custom(String),
}

/// ç½‘å…³ç®¡ç†å™¨ - æ¡†æ¶æä¾›
pub struct GatewayManager {
    gateways: HashMap<String, Box<dyn Gateway>>,
    active_gateway: Option<String>,
    gateway_stats: HashMap<String, GatewayStatistics>,
}

impl GatewayManager {
    /// æ³¨å†Œç½‘å…³ - ç”¨æˆ·æ‰©å±•ç‚¹
    pub async fn register_gateway(&mut self, gateway: Box<dyn Gateway>) -> Result<()> {
        let gateway_id = gateway.gateway_id().to_string();
        self.gateways.insert(gateway_id, gateway);
        Ok(())
    }
    
    /// è®¾ç½®æ´»åŠ¨ç½‘å…³
    pub fn set_active_gateway(&mut self, gateway_id: &str) -> Result<()> {
        if self.gateways.contains_key(gateway_id) {
            self.active_gateway = Some(gateway_id.to_string());
            Ok(())
        } else {
            Err(CzscError::GatewayNotFound(gateway_id.to_string()))
        }
    }
}
```

### 3.4 é£é™©æ¨¡å‹æ¥å£

```rust
// ================================
// å¯æ’æ‹”æ¥å£ï¼šé£é™©ç®¡ç†ç³»ç»Ÿ
// ä½ç½®ï¼šsrc/risk/traits.rs
// ç‰¹ç‚¹ï¼šç”¨æˆ·å®ç°è‡ªå®šä¹‰é£é™©æ¨¡å‹
// ================================

/// é£é™©æ¨¡å‹ç‰¹å¾ - ç”¨æˆ·æ‰©å±•ç‚¹
#[async_trait]
pub trait RiskModel: Send + Sync {
    // === æ ¸å¿ƒé£é™©æ£€æŸ¥ ===
    async fn check_order_risk(&self, order: &Order, context: &RiskContext) -> Result<RiskCheckResult>;
    async fn check_portfolio_risk(&self, portfolio: &Portfolio, context: &RiskContext) -> Result<RiskAssessment>;
    
    // === å…ƒä¿¡æ¯ ===
    fn model_id(&self) -> &str;
    fn model_type(&self) -> RiskModelType;
    fn risk_categories(&self) -> Vec<RiskCategory>;
    
    // === é…ç½®ç®¡ç† ===
    fn get_limits(&self) -> RiskLimits;
    fn set_limits(&mut self, limits: RiskLimits) -> Result<()>;
    
    // === å¯é€‰æ–¹æ³• ===
    async fn calculate_var(&self, _portfolio: &Portfolio, _confidence: f64) -> Result<Price> {
        Err(CzscError::NotSupported("VaR calculation not supported".to_string()))
    }
    
    async fn stress_test(&self, _portfolio: &Portfolio, _scenarios: &[StressScenario]) -> Result<StressTestResult> {
        Err(CzscError::NotSupported("Stress testing not supported".to_string()))
    }
}

/// é£é™©æ£€æŸ¥ç»“æœ
#[derive(Debug, Clone)]
pub struct RiskCheckResult {
    pub approved: bool,
    pub risk_score: f64,
    pub violated_limits: Vec<RiskLimitViolation>,
    pub warnings: Vec<String>,
    pub recommendations: Vec<String>,
}

/// é£é™©ä¸Šä¸‹æ–‡ - æ¡†æ¶æä¾›
pub struct RiskContext {
    pub current_time: TimestampNs,
    pub market_data: HashMap<Symbol, Bar>,
    pub open_orders: Vec<Order>,
    pub account_info: AccountInfo,
    pub market_conditions: MarketConditions,
}

/// é£é™©ç®¡ç†å™¨ - æ¡†æ¶å®ç°ï¼Œç»„åˆå¤šä¸ªé£é™©æ¨¡å‹
pub struct RiskManager {
    models: Vec<Box<dyn RiskModel>>,
    evaluation_strategy: RiskEvaluationStrategy,
    emergency_stops: Vec<EmergencyStop>,
}

impl RiskManager {
    /// æ³¨å†Œé£é™©æ¨¡å‹ - ç”¨æˆ·æ‰©å±•ç‚¹
    pub fn register_model(&mut self, model: Box<dyn RiskModel>) {
        self.models.push(model);
    }
    
    /// ç»¼åˆé£é™©è¯„ä¼°
    pub async fn evaluate_order_risk(&self, order: &Order, context: &RiskContext) -> Result<RiskCheckResult> {
        let mut results = Vec::new();
        
        // å¹¶è¡Œè¯„ä¼°æ‰€æœ‰é£é™©æ¨¡å‹
        for model in &self.models {
            let result = model.check_order_risk(order, context).await?;
            results.push(result);
        }
        
        // æ ¹æ®ç­–ç•¥åˆå¹¶ç»“æœ
        self.evaluation_strategy.combine_results(results)
    }
}
```

## 4. ç”¨æˆ·å®ç°æŒ‡å—

### 4.1 å®ç°è‡ªå®šä¹‰ç­–ç•¥

```rust
// ================================
// ç”¨æˆ·å®ç°ç¤ºä¾‹ï¼šè‡ªå®šä¹‰ç­–ç•¥
// ä½ç½®ï¼šç”¨æˆ·ä»£ç ç›®å½•
// ç‰¹ç‚¹ï¼šç”¨æˆ·å®Œå…¨æ§åˆ¶ç­–ç•¥é€»è¾‘
// ================================

use moses_quant::strategy::Strategy;
use moses_quant::types::*;

/// ç”¨æˆ·è‡ªå®šä¹‰ç­–ç•¥ç¤ºä¾‹
pub struct MyCustomStrategy {
    strategy_id: String,
    parameters: MyStrategyParams,
    state: MyStrategyState,
}

#[derive(Debug, Clone)]
struct MyStrategyParams {
    fast_period: usize,
    slow_period: usize,
    signal_threshold: f64,
}

#[derive(Debug, Default)]
struct MyStrategyState {
    fast_ema: f64,
    slow_ema: f64,
    last_signal: Option<Signal>,
}

#[async_trait]
impl Strategy for MyCustomStrategy {
    async fn on_start(&mut self, context: &StrategyContext) -> Result<()> {
        context.log(LogLevel::Info, "My custom strategy started");
        // åˆå§‹åŒ–ç­–ç•¥çŠ¶æ€
        self.initialize_indicators(context).await?;
        Ok(())
    }
    
    async fn on_data(&mut self, context: &StrategyContext, data: &MarketData) -> Result<Vec<Order>> {
        let mut orders = Vec::new();
        
        if let MarketData::Bar(bar) = data {
            // æ›´æ–°æŠ€æœ¯æŒ‡æ ‡
            self.update_indicators(bar);
            
            // ç”Ÿæˆäº¤æ˜“ä¿¡å·
            if let Some(signal) = self.generate_signal() {
                if let Some(order) = self.create_order_from_signal(&signal, bar, context).await? {
                    orders.push(order);
                }
            }
        }
        
        Ok(orders)
    }
    
    async fn on_order(&mut self, context: &StrategyContext, order: &Order) -> Result<()> {
        context.log(LogLevel::Info, &format!("Order update: {:?}", order.status));
        Ok(())
    }
    
    async fn on_trade(&mut self, context: &StrategyContext, trade: &Trade) -> Result<()> {
        context.log(LogLevel::Info, &format!("Trade executed: {}", trade.quantity));
        Ok(())
    }
    
    async fn on_stop(&mut self, context: &StrategyContext) -> Result<()> {
        context.log(LogLevel::Info, "Strategy stopped");
        Ok(())
    }
    
    fn strategy_id(&self) -> &str { &self.strategy_id }
    fn strategy_name(&self) -> &str { "MyCustomStrategy" }
    fn version(&self) -> &str { "1.0.0" }
}

impl MyCustomStrategy {
    pub fn new(strategy_id: String, params: MyStrategyParams) -> Self {
        Self {
            strategy_id,
            parameters: params,
            state: MyStrategyState::default(),
        }
    }
    
    // ç”¨æˆ·å®Œå…¨æ§åˆ¶çš„ç§æœ‰æ–¹æ³•
    fn update_indicators(&mut self, bar: &Bar) {
        let price = bar.close.to_f64().unwrap();
        let alpha_fast = 2.0 / (self.parameters.fast_period as f64 + 1.0);
        let alpha_slow = 2.0 / (self.parameters.slow_period as f64 + 1.0);
        
        self.state.fast_ema = alpha_fast * price + (1.0 - alpha_fast) * self.state.fast_ema;
        self.state.slow_ema = alpha_slow * price + (1.0 - alpha_slow) * self.state.slow_ema;
    }
    
    fn generate_signal(&mut self) -> Option<Signal> {
        let diff = self.state.fast_ema - self.state.slow_ema;
        
        if diff > self.parameters.signal_threshold {
            Some(Signal::Buy)
        } else if diff < -self.parameters.signal_threshold {
            Some(Signal::Sell)
        } else {
            None
        }
    }
}
```

### 4.2 å®ç°è‡ªå®šä¹‰æ•°æ®æº

```rust
// ================================
// ç”¨æˆ·å®ç°ç¤ºä¾‹ï¼šè‡ªå®šä¹‰æ•°æ®æº
// ä½ç½®ï¼šç”¨æˆ·ä»£ç ç›®å½•
// ç‰¹ç‚¹ï¼šç”¨æˆ·å®ç°å…·ä½“æ•°æ®è·å–é€»è¾‘
// ================================

use moses_quant::data::DataSource;
use moses_quant::types::*;

/// ç”¨æˆ·è‡ªå®šä¹‰æ•°æ®æº
pub struct MyDataProvider {
    source_id: String,
    api_client: MyAPIClient,
    subscriptions: HashSet<Symbol>,
    connection_state: ConnectionState,
}

#[async_trait]
impl DataSource for MyDataProvider {
    async fn connect(&mut self) -> Result<()> {
        self.api_client.connect().await?;
        self.connection_state = ConnectionState::Connected;
        Ok(())
    }
    
    async fn disconnect(&mut self) -> Result<()> {
        self.api_client.disconnect().await?;
        self.connection_state = ConnectionState::Disconnected;
        Ok(())
    }
    
    async fn subscribe(&mut self, symbols: Vec<Symbol>, data_types: Vec<DataType>) -> Result<()> {
        for symbol in symbols {
            // ç”¨æˆ·è‡ªå®šä¹‰çš„è®¢é˜…é€»è¾‘
            self.api_client.subscribe_symbol(&symbol).await?;
            self.subscriptions.insert(symbol);
        }
        Ok(())
    }
    
    async fn get_historical_data(&self, request: DataRequest) -> Result<Vec<Bar>> {
        // ç”¨æˆ·è‡ªå®šä¹‰çš„å†å²æ•°æ®è·å–é€»è¾‘
        let raw_data = self.api_client.fetch_historical_data(&request).await?;
        
        // è½¬æ¢ä¸ºæ¡†æ¶æ ‡å‡†æ ¼å¼
        let bars = raw_data.into_iter()
            .map(|raw_bar| self.convert_to_standard_bar(raw_bar))
            .collect::<Result<Vec<_>>>()?;
        
        Ok(bars)
    }
    
    fn source_id(&self) -> &str { &self.source_id }
    fn source_type(&self) -> DataSourceType { DataSourceType::RealTime }
    
    fn supported_symbols(&self) -> Vec<Symbol> {
        // è¿”å›æ”¯æŒçš„äº¤æ˜“å¯¹
        vec![
            Symbol::new("BTC/USDT"),
            Symbol::new("ETH/USDT"),
            // ... æ›´å¤šäº¤æ˜“å¯¹
        ]
    }
    
    fn supported_data_types(&self) -> Vec<DataType> {
        vec![DataType::Bar, DataType::Tick]
    }
}

impl MyDataProvider {
    pub fn new(source_id: String, api_config: MyAPIConfig) -> Self {
        Self {
            source_id,
            api_client: MyAPIClient::new(api_config),
            subscriptions: HashSet::new(),
            connection_state: ConnectionState::Disconnected,
        }
    }
    
    // ç”¨æˆ·è‡ªå®šä¹‰çš„æ•°æ®è½¬æ¢é€»è¾‘
    fn convert_to_standard_bar(&self, raw_bar: MyRawBar) -> Result<Bar> {
        Ok(Bar {
            symbol: Symbol::new(&raw_bar.symbol),
            timestamp: raw_bar.timestamp,
            open: Price::from_str(&raw_bar.open)?,
            high: Price::from_str(&raw_bar.high)?,
            low: Price::from_str(&raw_bar.low)?,
            close: Price::from_str(&raw_bar.close)?,
            volume: Quantity::from_str(&raw_bar.volume)?,
            turnover: raw_bar.turnover.map(|t| Price::from_str(&t)).transpose()?,
            trade_count: raw_bar.trade_count,
        })
    }
}
```

## 5. æ’ä»¶æ³¨å†Œå’Œé…ç½®

### 5.1 æ’ä»¶æ³¨å†Œç³»ç»Ÿ

```rust
// ================================
// æ¡†æ¶æä¾›ï¼šæ’ä»¶æ³¨å†Œç³»ç»Ÿ
// ä½ç½®ï¼šsrc/plugin/registry.rs
// ç‰¹ç‚¹ï¼šç±»å‹å®‰å…¨çš„æ’ä»¶ç®¡ç†
// ================================

/// æ’ä»¶æ³¨å†Œè¡¨ - æ¡†æ¶æ ¸å¿ƒç»„ä»¶
pub struct PluginRegistry {
    strategies: HashMap<String, Box<dyn Strategy>>,
    data_sources: HashMap<String, Box<dyn DataSource>>,
    gateways: HashMap<String, Box<dyn Gateway>>,
    risk_models: HashMap<String, Box<dyn RiskModel>>,
}

impl PluginRegistry {
    /// æ³¨å†Œç­–ç•¥æ’ä»¶
    pub fn register_strategy<T: Strategy + 'static>(&mut self, strategy: T) -> Result<()> {
        let strategy_id = strategy.strategy_id().to_string();
        if self.strategies.contains_key(&strategy_id) {
            return Err(CzscError::PluginAlreadyRegistered(strategy_id));
        }
        
        self.strategies.insert(strategy_id, Box::new(strategy));
        Ok(())
    }
    
    /// æ³¨å†Œæ•°æ®æºæ’ä»¶
    pub fn register_data_source<T: DataSource + 'static>(&mut self, data_source: T) -> Result<()> {
        let source_id = data_source.source_id().to_string();
        if self.data_sources.contains_key(&source_id) {
            return Err(CzscError::PluginAlreadyRegistered(source_id));
        }
        
        self.data_sources.insert(source_id, Box::new(data_source));
        Ok(())
    }
    
    /// ä»é…ç½®åˆ›å»ºç­–ç•¥å®ä¾‹
    pub fn create_strategy_from_config(&self, config: &StrategyConfig) -> Result<Box<dyn Strategy>> {
        match config.strategy_type.as_str() {
            "MyCustomStrategy" => {
                // ç”¨æˆ·éœ€è¦æä¾›å·¥å‚å‡½æ•°
                let params = serde_yaml::from_value(config.parameters.clone())?;
                Ok(Box::new(MyCustomStrategy::new(config.id.clone(), params)))
            }
            _ => Err(CzscError::UnknownStrategyType(config.strategy_type.clone()))
        }
    }
}

/// å…¨å±€æ’ä»¶æ³¨å†Œå®
#[macro_export]
macro_rules! register_plugin {
    (strategy: $strategy_type:ty) => {
        #[no_mangle]
        pub extern "C" fn register_strategy_plugin() -> Box<dyn Strategy> {
            Box::new(<$strategy_type>::default())
        }
    };
    
    (data_source: $data_source_type:ty) => {
        #[no_mangle]
        pub extern "C" fn register_data_source_plugin() -> Box<dyn DataSource> {
            Box::new(<$data_source_type>::default())
        }
    };
}
```

### 5.2 é…ç½®é©±åŠ¨çš„æ’ä»¶åŠ è½½

```yaml
# ================================
# ç”¨æˆ·é…ç½®æ–‡ä»¶ç¤ºä¾‹
# ä½ç½®ï¼šconfig/strategy.yaml
# ç‰¹ç‚¹ï¼šå£°æ˜å¼é…ç½®ï¼Œæ¡†æ¶è‡ªåŠ¨å®ä¾‹åŒ–
# ================================

framework:
  name: "MosesQuant"
  version: "0.1.0"
  initial_capital: 100000.0

# æ•°æ®æºé…ç½® - ç”¨æˆ·æ’ä»¶
data_sources:
  - id: "my_data_provider"
    type: "MyDataProvider"
    enabled: true
    config:
      api_key: "${MY_API_KEY}"
      api_secret: "${MY_API_SECRET}"
      base_url: "https://api.example.com"

# ç½‘å…³é…ç½® - ç”¨æˆ·æ’ä»¶
gateways:
  - id: "my_trading_gateway"
    type: "MyTradingGateway"
    enabled: true
    config:
      trading_mode: "paper"
      commission_rate: 0.001

# ç­–ç•¥é…ç½® - ç”¨æˆ·æ’ä»¶
strategies:
  - id: "my_custom_strategy"
    type: "MyCustomStrategy"
    enabled: true
    symbols: ["BTC/USDT", "ETH/USDT"]
    parameters:
      fast_period: 12
      slow_period: 26
      signal_threshold: 0.01

# é£é™©ç®¡ç†é…ç½® - ç”¨æˆ·æ’ä»¶
risk_management:
  models:
    - id: "position_size_risk"
      type: "PositionSizeRiskModel"
      config:
        max_position_size: 0.1
        max_total_exposure: 0.8
```

## 6. æ€»ç»“

### 6.1 æ¸…æ™°çš„è¾¹ç•Œåˆ’åˆ†

| ç»„ä»¶ç±»åˆ« | è´£ä»»èŒƒå›´ | ç”¨æˆ·å¯ä¿®æ”¹æ€§ | æ€§èƒ½ç‰¹å¾ |
|---------|---------|-------------|---------|
| **å…¬å…±æ ¸å¿ƒ** | åŸºç¡€è®¾æ–½ã€ç±»å‹ç³»ç»Ÿã€äº‹ä»¶æ€»çº¿ | âŒ ä¸å¯ä¿®æ”¹ | ğŸš€ é›¶æˆæœ¬æŠ½è±¡ |
| **å¯æ’æ‹”æ¥å£** | æ ‡å‡†åŒ–çš„æ‰©å±•ç‚¹ | âš¡ æ¥å£å›ºå®šï¼Œå®ç°è‡ªç”± | ğŸ¯ ç¼–è¯‘æ—¶å¤šæ€ |
| **ç”¨æˆ·å®ç°** | å…·ä½“ä¸šåŠ¡é€»è¾‘ | âœ… å®Œå…¨æ§åˆ¶ | ğŸ“Š æ€§èƒ½å–å†³äºå®ç°è´¨é‡ |

### 6.2 ä¼˜åŠ¿ç‰¹æ€§

1. **ç±»å‹å®‰å…¨** - Rustç¼–è¯‘å™¨ä¿è¯æ¥å£å¥‘çº¦
2. **é›¶è¿è¡Œæ—¶å¼€é”€** - ç¼–è¯‘æ—¶ç¡®å®šæ‰€æœ‰è°ƒç”¨
3. **å†…å­˜å®‰å…¨** - å€Ÿç”¨æ£€æŸ¥å™¨é˜²æ­¢æ•°æ®ç«äº‰
4. **æ¸è¿›å¼å¤æ‚åº¦** - ç®€å•æ¥å£å¼€å§‹ï¼Œéœ€è¦æ—¶æ‰©å±•
5. **é…ç½®é©±åŠ¨** - å£°æ˜å¼é…ç½®ï¼Œæ¡†æ¶è‡ªåŠ¨è£…é…

è¿™ç§è®¾è®¡ç¡®ä¿äº†æ¡†æ¶æ ¸å¿ƒçš„ç¨³å®šæ€§ï¼ŒåŒæ—¶ä¸ºç”¨æˆ·æä¾›äº†æœ€å¤§çš„æ‰©å±•è‡ªç”±åº¦å’Œæ€§èƒ½ä¿è¯ã€‚