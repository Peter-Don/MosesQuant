# è·¨æ’ä»¶é€šä¿¡ä¸ä¾èµ–ç®¡ç†æœºåˆ¶è®¾è®¡

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
> **åˆ›å»ºæ—¥æœŸ**: 2025-07-18  
> **è®¾è®¡ç†å¿µ**: åŸºäºRustç±»å‹ç³»ç»Ÿçš„é›¶æˆæœ¬æ’ä»¶é—´é€šä¿¡  
> **ç›®æ ‡**: å®ç°é«˜æ•ˆã€å®‰å…¨ã€å¯æ‰©å±•çš„æ’ä»¶åä½œæœºåˆ¶

## 1. é€šä¿¡æ¨¡å¼è®¾è®¡æ¦‚è§ˆ

### 1.1 å››ç§é€šä¿¡æ¨¡å¼

```mermaid
graph TD
    subgraph "æ’ä»¶é€šä¿¡æ¨¡å¼"
        A1[ç›´æ¥ä¾èµ–è°ƒç”¨<br/>Direct Dependency Call]
        A2[äº‹ä»¶å‘å¸ƒè®¢é˜…<br/>Event Pub/Sub]
        A3[æ¶ˆæ¯ä¼ é€’<br/>Message Passing]
        A4[å…±äº«çŠ¶æ€è®¿é—®<br/>Shared State Access]
    end
    
    subgraph "ç‰¹æ€§å¯¹æ¯”"
        B1[åŒæ­¥ + ç±»å‹å®‰å…¨<br/>é«˜æ€§èƒ½]
        B2[å¼‚æ­¥ + è§£è€¦<br/>ä¸€å¯¹å¤šé€šä¿¡]
        B3[å¼‚æ­¥ + å¯æŒä¹…åŒ–<br/>è·¨æ—¶é—´é€šä¿¡]
        B4[è¯»ä¼˜åŒ– + ç¼“å­˜å‹å¥½<br/>æ•°æ®å…±äº«]
    end
    
    A1 --> B1
    A2 --> B2
    A3 --> B3
    A4 --> B4
```

### 1.2 é€šä¿¡æ¨¡å¼é€‰æ‹©çŸ©é˜µ

| åœºæ™¯ | åŒæ­¥æ€§ | è€¦åˆåº¦ | æ•°æ®é‡ | æ¨èæ¨¡å¼ |
|-----|-------|-------|--------|---------|
| ç­–ç•¥è°ƒç”¨é£é™©æ£€æŸ¥ | åŒæ­¥ | ç´§è€¦åˆ | å° | ç›´æ¥ä¾èµ–è°ƒç”¨ |
| å¸‚åœºæ•°æ®åˆ†å‘ | å¼‚æ­¥ | æ¾è€¦åˆ | å¤§ | äº‹ä»¶å‘å¸ƒè®¢é˜… |
| ç­–ç•¥é—´åè°ƒ | å¼‚æ­¥ | æ¾è€¦åˆ | ä¸­ | æ¶ˆæ¯ä¼ é€’ |
| è®¿é—®é…ç½®ä¿¡æ¯ | åŒæ­¥ | æ¾è€¦åˆ | å° | å…±äº«çŠ¶æ€è®¿é—® |

## 2. ç›´æ¥ä¾èµ–è°ƒç”¨æœºåˆ¶

### 2.1 ç±»å‹å®‰å…¨çš„ä¾èµ–æ³¨å…¥

```rust
/// ä¾èµ–æ³¨å…¥å®¹å™¨ - ç¼–è¯‘æ—¶ç±»å‹å®‰å…¨
pub struct DependencyContainer {
    plugins: HashMap<TypeId, Box<dyn Any + Send + Sync>>,
    plugin_map: HashMap<PluginId, TypeId>,
}

impl DependencyContainer {
    /// æ³¨å†Œæ’ä»¶å®ä¾‹
    pub fn register<T: Plugin + 'static>(&mut self, plugin: Arc<T>) -> Result<()> {
        let type_id = TypeId::of::<T>();
        let plugin_id = plugin.plugin_id().clone();
        
        self.plugins.insert(type_id, Box::new(plugin));
        self.plugin_map.insert(plugin_id, type_id);
        
        Ok(())
    }
    
    /// è·å–æ’ä»¶ä¾èµ– - é›¶æˆæœ¬æŠ½è±¡
    pub fn get<T: Plugin + 'static>(&self) -> Result<Arc<T>> {
        let type_id = TypeId::of::<T>();
        
        self.plugins.get(&type_id)
            .ok_or_else(|| CzscError::DependencyNotFound(type_name::<T>().to_string()))?
            .downcast_ref::<Arc<T>>()
            .ok_or_else(|| CzscError::TypeMismatch)?
            .clone()
            .pipe(Ok)
    }
    
    /// æŒ‰IDè·å–æ’ä»¶
    pub fn get_by_id<T: Plugin + 'static>(&self, plugin_id: &PluginId) -> Result<Arc<T>> {
        let type_id = self.plugin_map.get(plugin_id)
            .ok_or_else(|| CzscError::PluginNotFound(plugin_id.to_string()))?;
        
        self.plugins.get(type_id)
            .ok_or_else(|| CzscError::DependencyNotFound(plugin_id.to_string()))?
            .downcast_ref::<Arc<T>>()
            .ok_or_else(|| CzscError::TypeMismatch)?
            .clone()
            .pipe(Ok)
    }
}

/// ä¾èµ–è®¿é—®ç‰¹å¾ - ä¸ºæ’ä»¶æä¾›ä¾èµ–è®¿é—®èƒ½åŠ›
#[async_trait]
pub trait DependencyAccess {
    /// è·å–å¼ºç±»å‹ä¾èµ–
    async fn get_dependency<T: Plugin + 'static>(&self) -> Result<Arc<T>>;
    
    /// æ£€æŸ¥ä¾èµ–æ˜¯å¦å¯ç”¨
    async fn has_dependency<T: Plugin + 'static>(&self) -> bool;
    
    /// ç­‰å¾…ä¾èµ–å¯ç”¨
    async fn wait_for_dependency<T: Plugin + 'static>(&self, timeout: Duration) -> Result<Arc<T>>;
}

/// ç­–ç•¥æ’ä»¶ä¾èµ–ä½¿ç”¨ç¤ºä¾‹
impl MyTradingStrategy {
    /// ä½¿ç”¨é£é™©æ¨¡å‹è¿›è¡Œé£é™©æ£€æŸ¥
    async fn check_order_risk(&self, order: &Order) -> Result<bool> {
        // ç›´æ¥è·å–é£é™©æ¨¡å‹ä¾èµ– - ç¼–è¯‘æ—¶ç±»å‹å®‰å…¨
        let risk_model = self.get_dependency::<MyRiskModel>().await?;
        
        let risk_context = self.build_risk_context().await?;
        let result = risk_model.check_order_risk(order, &risk_context).await?;
        
        Ok(result.approved)
    }
    
    /// ä½¿ç”¨æ•°æ®æºè·å–å†å²æ•°æ®
    async fn get_market_data(&self, symbol: &Symbol) -> Result<Vec<Bar>> {
        let data_source = self.get_dependency::<BinanceDataSource>().await?;
        
        let request = DataRequest {
            symbol: symbol.clone(),
            data_type: DataType::Bar,
            count: Some(100),
            ..Default::default()
        };
        
        data_source.get_historical_data(request).await
    }
}
```

### 2.2 ä¾èµ–ä»£ç†æ¨¡å¼

```rust
/// ä¾èµ–ä»£ç† - å»¶è¿Ÿè§£æå’Œç¼“å­˜ä¼˜åŒ–
pub struct DependencyProxy<T: Plugin> {
    dependency: OnceCell<Arc<T>>,
    container: Arc<DependencyContainer>,
    plugin_id: Option<PluginId>,
}

impl<T: Plugin + 'static> DependencyProxy<T> {
    pub fn new(container: Arc<DependencyContainer>) -> Self {
        Self {
            dependency: OnceCell::new(),
            container,
            plugin_id: None,
        }
    }
    
    pub fn new_with_id(container: Arc<DependencyContainer>, plugin_id: PluginId) -> Self {
        Self {
            dependency: OnceCell::new(),
            container,
            plugin_id: Some(plugin_id),
        }
    }
    
    /// è·å–ä¾èµ– - å»¶è¿Ÿåˆå§‹åŒ– + ç¼“å­˜
    pub async fn get(&self) -> Result<Arc<T>> {
        // å¦‚æœå·²ç¼“å­˜ï¼Œç›´æ¥è¿”å›
        if let Some(dep) = self.dependency.get() {
            return Ok(Arc::clone(dep));
        }
        
        // å»¶è¿Ÿè§£æä¾èµ–
        let dependency = if let Some(ref plugin_id) = self.plugin_id {
            self.container.get_by_id::<T>(plugin_id)?
        } else {
            self.container.get::<T>()?
        };
        
        // ç¼“å­˜è§£æç»“æœ
        let _ = self.dependency.set(Arc::clone(&dependency));
        
        Ok(dependency)
    }
    
    /// æ£€æŸ¥ä¾èµ–æ˜¯å¦å·²è§£æ
    pub fn is_resolved(&self) -> bool {
        self.dependency.get().is_some()
    }
}

/// ä¾èµ–ä»£ç†çš„ä½¿ç”¨ç¤ºä¾‹
pub struct MyStrategy {
    risk_model: DependencyProxy<dyn RiskModelPlugin>,
    data_source: DependencyProxy<dyn DataSourcePlugin>,
    gateway: DependencyProxy<dyn GatewayPlugin>,
}

impl MyStrategy {
    pub fn new(container: Arc<DependencyContainer>) -> Self {
        Self {
            risk_model: DependencyProxy::new(Arc::clone(&container)),
            data_source: DependencyProxy::new_with_id(
                Arc::clone(&container), 
                PluginId::new("binance_data")
            ),
            gateway: DependencyProxy::new_with_id(
                container, 
                PluginId::new("binance_gateway")
            ),
        }
    }
    
    async fn execute_trade(&self, signal: &TradingSignal) -> Result<()> {
        // 1. é£é™©æ£€æŸ¥ - ç›´æ¥ä¾èµ–è°ƒç”¨
        let risk_check = self.risk_model.get().await?
            .check_order_risk(&signal.to_order(), &self.build_risk_context().await?)
            .await?;
        
        if !risk_check.approved {
            return Err(CzscError::RiskCheckFailed(risk_check.violated_limits));
        }
        
        // 2. æ‰§è¡Œè®¢å•
        let order_response = self.gateway.get().await?
            .submit_order(signal.to_order())
            .await?;
        
        info!("Order submitted: {:?}", order_response);
        Ok(())
    }
}
```

## 3. äº‹ä»¶å‘å¸ƒè®¢é˜…æœºåˆ¶

### 3.3 ç±»å‹å®‰å…¨çš„äº‹ä»¶ç³»ç»Ÿ

```rust
/// äº‹ä»¶å‘å¸ƒè®¢é˜…æ€»çº¿ - ç±»å‹å®‰å…¨ + é«˜æ€§èƒ½
pub struct EventBus {
    // ä½¿ç”¨TypeIdä½œä¸ºé”®ï¼Œå®ç°ç¼–è¯‘æ—¶ç±»å‹å®‰å…¨
    subscribers: Arc<RwLock<HashMap<TypeId, Vec<BoxedEventHandler>>>>,
    
    // äº‹ä»¶é˜Ÿåˆ— - ä¸åŒä¼˜å…ˆçº§çš„é˜Ÿåˆ—
    event_queues: [Arc<AsyncQueue<BoxedEvent>>; 4], // Critical, High, Normal, Low
    
    // æ€§èƒ½ç»Ÿè®¡
    stats: Arc<RwLock<EventBusStatistics>>,
    
    // é…ç½®
    config: EventBusConfig,
}

/// å¼ºç±»å‹äº‹ä»¶å¤„ç†å™¨
#[async_trait]
pub trait TypedEventHandler<T: Event>: Send + Sync {
    async fn handle(&self, event: &T) -> Result<()>;
    fn handler_id(&self) -> &str;
    fn can_handle_parallel(&self) -> bool { true }
}

/// äº‹ä»¶å¤„ç†å™¨åŒ…è£…å™¨ - å®ç°ç±»å‹æ“¦é™¤
struct EventHandlerWrapper<T: Event> {
    handler: Box<dyn TypedEventHandler<T>>,
}

#[async_trait]
impl<T: Event + 'static> EventHandler for EventHandlerWrapper<T> {
    async fn handle(&self, event: &dyn Event) -> Result<()> {
        if let Some(typed_event) = event.as_any().downcast_ref::<T>() {
            self.handler.handle(typed_event).await
        } else {
            Err(CzscError::TypeMismatch)
        }
    }
}

impl EventBus {
    /// è®¢é˜…ç‰¹å®šç±»å‹çš„äº‹ä»¶ - ç¼–è¯‘æ—¶ç±»å‹å®‰å…¨
    pub async fn subscribe<T: Event + 'static>(
        &self,
        handler: Box<dyn TypedEventHandler<T>>
    ) -> Result<SubscriptionHandle> {
        let type_id = TypeId::of::<T>();
        let wrapped_handler = Box::new(EventHandlerWrapper { handler });
        
        let mut subscribers = self.subscribers.write().await;
        subscribers.entry(type_id)
            .or_insert_with(Vec::new)
            .push(wrapped_handler);
        
        let handle = SubscriptionHandle::new(type_id, wrapped_handler.handler_id().to_string());
        Ok(handle)
    }
    
    /// å‘å¸ƒäº‹ä»¶ - é›¶æ‹·è´ä¼˜åŒ–
    pub async fn publish<T: Event + 'static>(&self, event: T) -> Result<()> {
        let priority = event.priority();
        let boxed_event = Box::new(event) as BoxedEvent;
        
        // æ ¹æ®ä¼˜å…ˆçº§é€‰æ‹©é˜Ÿåˆ—
        let queue_index = match priority {
            EventPriority::Critical => 0,
            EventPriority::High => 1,
            EventPriority::Normal => 2,
            EventPriority::Low => 3,
        };
        
        self.event_queues[queue_index].push(boxed_event).await?;
        
        // æ›´æ–°ç»Ÿè®¡
        self.stats.write().await.events_published += 1;
        
        Ok(())
    }
    
    /// æ‰¹é‡å‘å¸ƒäº‹ä»¶ - æ€§èƒ½ä¼˜åŒ–
    pub async fn publish_batch<T: Event + 'static>(&self, events: Vec<T>) -> Result<()> {
        if events.is_empty() {
            return Ok(());
        }
        
        // æŒ‰ä¼˜å…ˆçº§åˆ†ç»„
        let mut grouped_events: [Vec<BoxedEvent>; 4] = Default::default();
        
        for event in events {
            let queue_index = match event.priority() {
                EventPriority::Critical => 0,
                EventPriority::High => 1,
                EventPriority::Normal => 2,
                EventPriority::Low => 3,
            };
            
            grouped_events[queue_index].push(Box::new(event));
        }
        
        // æ‰¹é‡æ¨é€åˆ°å¯¹åº”é˜Ÿåˆ—
        for (i, events) in grouped_events.into_iter().enumerate() {
            if !events.is_empty() {
                self.event_queues[i].push_batch(events).await?;
            }
        }
        
        Ok(())
    }
}

/// å¸‚åœºæ•°æ®äº‹ä»¶ç¤ºä¾‹
#[derive(Debug, Clone)]
pub struct MarketDataEvent {
    pub symbol: Symbol,
    pub data: MarketDataPayload,
    pub timestamp: i64,
    pub source: String,
}

impl Event for MarketDataEvent {
    fn event_type(&self) -> &'static str { "MarketData" }
    fn timestamp(&self) -> i64 { self.timestamp }
    fn priority(&self) -> EventPriority { EventPriority::High }
    fn source(&self) -> &str { &self.source }
}

/// ç­–ç•¥æ’ä»¶è®¢é˜…å¸‚åœºæ•°æ®
impl MyTradingStrategy {
    pub async fn setup_event_subscriptions(&self, event_bus: &EventBus) -> Result<()> {
        // è®¢é˜…å¸‚åœºæ•°æ®äº‹ä»¶
        let market_data_handler = MarketDataHandler::new(self.clone());
        event_bus.subscribe::<MarketDataEvent>(Box::new(market_data_handler)).await?;
        
        // è®¢é˜…äº¤æ˜“äº‹ä»¶
        let trade_handler = TradeEventHandler::new(self.clone());
        event_bus.subscribe::<TradeExecutedEvent>(Box::new(trade_handler)).await?;
        
        Ok(())
    }
}

/// å¸‚åœºæ•°æ®äº‹ä»¶å¤„ç†å™¨
pub struct MarketDataHandler {
    strategy: Arc<MyTradingStrategy>,
}

#[async_trait]
impl TypedEventHandler<MarketDataEvent> for MarketDataHandler {
    async fn handle(&self, event: &MarketDataEvent) -> Result<()> {
        // ç±»å‹å®‰å…¨çš„äº‹ä»¶å¤„ç†
        if let MarketDataPayload::Bar(ref bar) = event.data {
            self.strategy.on_bar_received(bar).await?;
        }
        
        Ok(())
    }
    
    fn handler_id(&self) -> &str { "market_data_handler" }
    fn can_handle_parallel(&self) -> bool { false } // ç­–ç•¥éœ€è¦é¡ºåºå¤„ç†
}
```

## 4. æ¶ˆæ¯ä¼ é€’æœºåˆ¶

### 4.1 å¼‚æ­¥æ¶ˆæ¯ä¼ é€’ç³»ç»Ÿ

```rust
/// æ’ä»¶é—´æ¶ˆæ¯æ€»çº¿
pub struct PluginMessageBus {
    // æ¶ˆæ¯è·¯ç”±è¡¨
    routes: Arc<RwLock<HashMap<PluginId, MessageChannel>>>,
    
    // æ¶ˆæ¯é˜Ÿåˆ—
    message_queues: Arc<DashMap<PluginId, Arc<AsyncQueue<PluginMessage>>>>,
    
    // æ¶ˆæ¯å¤„ç†å™¨æ³¨å†Œè¡¨
    handlers: Arc<RwLock<HashMap<PluginId, Vec<BoxedMessageHandler>>>>,
    
    // æ¶ˆæ¯ç»Ÿè®¡
    stats: Arc<RwLock<MessageBusStatistics>>,
    
    // æŒä¹…åŒ–æ”¯æŒ
    persistence: Option<Arc<dyn MessagePersistence>>,
}

/// æ’ä»¶æ¶ˆæ¯å®šä¹‰
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PluginMessage {
    pub id: MessageId,
    pub from: PluginId,
    pub to: PluginId,
    pub message_type: String,
    pub payload: serde_json::Value,
    pub timestamp: i64,
    pub priority: MessagePriority,
    pub reply_to: Option<MessageId>,
    pub expires_at: Option<i64>,
    pub retry_count: u32,
    pub max_retries: u32,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum MessagePriority {
    Critical = 0,
    High = 1,
    Normal = 2,
    Low = 3,
}

/// å¼ºç±»å‹æ¶ˆæ¯æ¥å£
pub trait TypedMessage: Serialize + DeserializeOwned + Send + Sync + 'static {
    fn message_type() -> &'static str;
    fn priority() -> MessagePriority { MessagePriority::Normal }
    fn max_retries() -> u32 { 3 }
    fn expires_after() -> Option<Duration> { None }
}

/// æ¶ˆæ¯å¤„ç†å™¨æ¥å£
#[async_trait]
pub trait MessageHandler<T: TypedMessage>: Send + Sync {
    async fn handle(&self, message: &T, context: &MessageContext) -> Result<()>;
    fn handler_id(&self) -> &str;
}

impl PluginMessageBus {
    /// å‘é€å¼ºç±»å‹æ¶ˆæ¯
    pub async fn send_typed_message<T: TypedMessage>(
        &self,
        from: PluginId,
        to: PluginId,
        message: T
    ) -> Result<MessageId> {
        let message_id = MessageId::new();
        let timestamp = chrono::Utc::now().timestamp();
        
        let plugin_message = PluginMessage {
            id: message_id.clone(),
            from,
            to: to.clone(),
            message_type: T::message_type().to_string(),
            payload: serde_json::to_value(message)?,
            timestamp,
            priority: T::priority(),
            reply_to: None,
            expires_at: T::expires_after().map(|d| timestamp + d.as_secs() as i64),
            retry_count: 0,
            max_retries: T::max_retries(),
        };
        
        self.route_message(plugin_message).await?;
        Ok(message_id)
    }
    
    /// å‘é€è¯·æ±‚-å“åº”æ¶ˆæ¯
    pub async fn send_request<Req: TypedMessage, Resp: TypedMessage>(
        &self,
        from: PluginId,
        to: PluginId,
        request: Req,
        timeout: Duration
    ) -> Result<Resp> {
        let message_id = self.send_typed_message(from.clone(), to, request).await?;
        
        // ç­‰å¾…å“åº”
        let response = self.wait_for_response::<Resp>(&message_id, timeout).await?;
        Ok(response)
    }
    
    /// æ³¨å†Œæ¶ˆæ¯å¤„ç†å™¨
    pub async fn register_handler<T: TypedMessage>(
        &self,
        plugin_id: PluginId,
        handler: Box<dyn MessageHandler<T>>
    ) -> Result<()> {
        let wrapped_handler = Box::new(TypedMessageHandlerWrapper {
            handler,
            message_type: T::message_type().to_string(),
        });
        
        let mut handlers = self.handlers.write().await;
        handlers.entry(plugin_id)
            .or_insert_with(Vec::new)
            .push(wrapped_handler);
        
        Ok(())
    }
}

/// ç­–ç•¥åè°ƒæ¶ˆæ¯ç¤ºä¾‹
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StrategyCoordinationMessage {
    pub action: CoordinationAction,
    pub symbol: Symbol,
    pub quantity: f64,
    pub price: Option<f64>,
    pub metadata: HashMap<String, Value>,
}

impl TypedMessage for StrategyCoordinationMessage {
    fn message_type() -> &'static str { "strategy_coordination" }
    fn priority() -> MessagePriority { MessagePriority::High }
    fn max_retries() -> u32 { 1 } // åè°ƒæ¶ˆæ¯é‡è¯•æ¬¡æ•°å°‘
    fn expires_after() -> Option<Duration> { Some(Duration::from_secs(30)) }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum CoordinationAction {
    RequestPosition,
    ReleasePosition,
    ShareSignal,
    SyncState,
}

/// ç­–ç•¥åè°ƒå¤„ç†å™¨
pub struct StrategyCoordinationHandler {
    strategy: Arc<MyTradingStrategy>,
}

#[async_trait]
impl MessageHandler<StrategyCoordinationMessage> for StrategyCoordinationHandler {
    async fn handle(&self, message: &StrategyCoordinationMessage, context: &MessageContext) -> Result<()> {
        match message.action {
            CoordinationAction::RequestPosition => {
                self.handle_position_request(message, context).await?;
            }
            CoordinationAction::ShareSignal => {
                self.handle_signal_sharing(message, context).await?;
            }
            _ => {
                debug!("Unhandled coordination action: {:?}", message.action);
            }
        }
        
        Ok(())
    }
    
    fn handler_id(&self) -> &str { "strategy_coordination_handler" }
}
```

## 5. å…±äº«çŠ¶æ€è®¿é—®æœºåˆ¶

### 5.1 è¯»ä¼˜åŒ–çš„å…±äº«çŠ¶æ€

```rust
/// å…±äº«çŠ¶æ€ç®¡ç†å™¨ - è¯»ä¼˜åŒ–
pub struct SharedStateManager {
    // é…ç½®çŠ¶æ€ - è¯»é¢‘ç¹ï¼Œå†™å¾ˆå°‘
    config_state: Arc<RwLock<ConfigState>>,
    
    // å¸‚åœºçŠ¶æ€ - è¯»é¢‘ç¹ï¼Œå†™ä¸­ç­‰
    market_state: Arc<RwLock<MarketState>>,
    
    // æŠ•èµ„ç»„åˆçŠ¶æ€ - è¯»å†™éƒ½é¢‘ç¹
    portfolio_state: Arc<RwLock<PortfolioState>>,
    
    // ç¼“å­˜å±‚ - è¿›ä¸€æ­¥ä¼˜åŒ–è¯»æ€§èƒ½
    cache: Arc<StateCache>,
    
    // å˜æ›´é€šçŸ¥
    change_notifier: Arc<StateChangeNotifier>,
}

/// é…ç½®çŠ¶æ€ - å‡ ä¹åªè¯»
#[derive(Debug, Clone)]
pub struct ConfigState {
    pub framework_config: FrameworkConfig,
    pub plugin_configs: HashMap<PluginId, PluginConfig>,
    pub risk_limits: RiskLimits,
    pub trading_params: TradingParameters,
}

/// å¸‚åœºçŠ¶æ€ - é¢‘ç¹æ›´æ–°
#[derive(Debug, Clone)]
pub struct MarketState {
    pub latest_prices: HashMap<Symbol, Price>,
    pub market_hours: MarketHours,
    pub volatility_regime: VolatilityRegime,
    pub liquidity_conditions: LiquidityConditions,
    pub last_updated: i64,
}

/// æŠ•èµ„ç»„åˆçŠ¶æ€ - è¯»å†™é¢‘ç¹
#[derive(Debug, Clone)]
pub struct PortfolioState {
    pub positions: HashMap<Symbol, Position>,
    pub cash_balance: Price,
    pub total_value: Price,
    pub unrealized_pnl: Price,
    pub realized_pnl: Price,
    pub last_updated: i64,
}

impl SharedStateManager {
    /// è·å–é…ç½®çŠ¶æ€ - ç¼“å­˜ä¼˜åŒ–
    pub async fn get_config(&self) -> Arc<ConfigState> {
        // æ£€æŸ¥ç¼“å­˜
        if let Some(cached_config) = self.cache.get_config().await {
            return cached_config;
        }
        
        // è¯»å–æœ€æ–°é…ç½®
        let config = self.config_state.read().await;
        let config_arc = Arc::new(config.clone());
        
        // æ›´æ–°ç¼“å­˜
        self.cache.set_config(Arc::clone(&config_arc)).await;
        
        config_arc
    }
    
    /// è·å–å¸‚åœºçŠ¶æ€å¿«ç…§
    pub async fn get_market_snapshot(&self) -> MarketState {
        self.market_state.read().await.clone()
    }
    
    /// åŸå­æ›´æ–°å¸‚åœºä»·æ ¼
    pub async fn update_price(&self, symbol: Symbol, price: Price) -> Result<()> {
        let mut market_state = self.market_state.write().await;
        market_state.latest_prices.insert(symbol.clone(), price);
        market_state.last_updated = chrono::Utc::now().timestamp();
        
        // é€šçŸ¥å˜æ›´
        self.change_notifier.notify_price_change(symbol, price).await;
        
        Ok(())
    }
    
    /// æ‰¹é‡æ›´æ–°ä»·æ ¼ - å‡å°‘é”äº‰ç”¨
    pub async fn update_prices_batch(&self, price_updates: Vec<(Symbol, Price)>) -> Result<()> {
        if price_updates.is_empty() {
            return Ok(());
        }
        
        let timestamp = chrono::Utc::now().timestamp();
        
        {
            let mut market_state = self.market_state.write().await;
            for (symbol, price) in &price_updates {
                market_state.latest_prices.insert(symbol.clone(), *price);
            }
            market_state.last_updated = timestamp;
        }
        
        // æ‰¹é‡é€šçŸ¥å˜æ›´
        self.change_notifier.notify_price_changes_batch(price_updates).await;
        
        Ok(())
    }
}

/// çŠ¶æ€ç¼“å­˜ - è¿›ä¸€æ­¥ä¼˜åŒ–è¯»æ€§èƒ½
pub struct StateCache {
    config_cache: Arc<ArcSwap<Option<Arc<ConfigState>>>>,
    market_cache: Arc<ArcSwap<Option<Arc<MarketState>>>>,
    price_cache: Arc<DashMap<Symbol, (Price, i64)>>, // (ä»·æ ¼, ç¼“å­˜æ—¶é—´)
    
    cache_ttl: Duration,
}

impl StateCache {
    /// è·å–ç¼“å­˜çš„é…ç½®
    pub async fn get_config(&self) -> Option<Arc<ConfigState>> {
        self.config_cache.load().as_ref().clone()
    }
    
    /// ç¼“å­˜é…ç½®
    pub async fn set_config(&self, config: Arc<ConfigState>) {
        self.config_cache.store(Arc::new(Some(config)));
    }
    
    /// è·å–ç¼“å­˜çš„ä»·æ ¼
    pub fn get_price(&self, symbol: &Symbol) -> Option<Price> {
        if let Some((price, cached_at)) = self.price_cache.get(symbol) {
            let now = chrono::Utc::now().timestamp();
            if now - *cached_at < self.cache_ttl.as_secs() as i64 {
                return Some(*price);
            }
        }
        None
    }
    
    /// ç¼“å­˜ä»·æ ¼
    pub fn set_price(&self, symbol: Symbol, price: Price) {
        let now = chrono::Utc::now().timestamp();
        self.price_cache.insert(symbol, (price, now));
    }
}

/// çŠ¶æ€è®¿é—®ä»£ç† - ä¸ºæ’ä»¶æä¾›ä¾¿æ·è®¿é—®
pub struct StateAccessProxy {
    state_manager: Arc<SharedStateManager>,
    plugin_id: PluginId,
}

impl StateAccessProxy {
    /// è·å–æœ€æ–°ä»·æ ¼ - ç¼“å­˜ä¼˜åŒ–
    pub async fn get_latest_price(&self, symbol: &Symbol) -> Result<Price> {
        // å…ˆæ£€æŸ¥ç¼“å­˜
        if let Some(price) = self.state_manager.cache.get_price(symbol) {
            return Ok(price);
        }
        
        // ä»å…±äº«çŠ¶æ€è¯»å–
        let market_state = self.state_manager.market_state.read().await;
        let price = market_state.latest_prices.get(symbol)
            .copied()
            .ok_or_else(|| CzscError::PriceNotFound(symbol.clone()))?;
        
        // æ›´æ–°ç¼“å­˜
        self.state_manager.cache.set_price(symbol.clone(), price);
        
        Ok(price)
    }
    
    /// è·å–é…ç½®å‚æ•°
    pub async fn get_config_value<T: DeserializeOwned>(&self, key: &str) -> Result<T> {
        let config = self.state_manager.get_config().await;
        
        if let Some(plugin_config) = config.plugin_configs.get(&self.plugin_id) {
            if let Some(value) = plugin_config.parameters.get(key) {
                return Ok(serde_json::from_value(value.clone())?);
            }
        }
        
        Err(CzscError::ConfigNotFound(key.to_string()))
    }
    
    /// è·å–æŠ•èµ„ç»„åˆä¿¡æ¯
    pub async fn get_portfolio_value(&self) -> Result<Price> {
        let portfolio = self.state_manager.portfolio_state.read().await;
        Ok(portfolio.total_value)
    }
}
```

## 6. æ€§èƒ½ç›‘æ§å’Œè°ƒè¯•

### 6.1 é€šä¿¡æ€§èƒ½ç›‘æ§

```rust
/// è·¨æ’ä»¶é€šä¿¡æ€§èƒ½ç›‘æ§å™¨
pub struct CommunicationMonitor {
    // è°ƒç”¨ç»Ÿè®¡
    call_stats: Arc<DashMap<(PluginId, PluginId), CallStatistics>>,
    
    // äº‹ä»¶ç»Ÿè®¡
    event_stats: Arc<DashMap<String, EventStatistics>>, // event_type -> stats
    
    // æ¶ˆæ¯ç»Ÿè®¡
    message_stats: Arc<DashMap<String, MessageStatistics>>, // message_type -> stats
    
    // å…±äº«çŠ¶æ€è®¿é—®ç»Ÿè®¡
    state_access_stats: Arc<DashMap<String, StateAccessStatistics>>,
}

#[derive(Debug, Clone)]
pub struct CallStatistics {
    pub total_calls: u64,
    pub successful_calls: u64,
    pub failed_calls: u64,
    pub average_latency: Duration,
    pub max_latency: Duration,
    pub last_call_time: i64,
}

#[derive(Debug, Clone)]
pub struct EventStatistics {
    pub events_published: u64,
    pub events_handled: u64,
    pub average_handling_time: Duration,
    pub failed_handling_count: u64,
    pub last_event_time: i64,
}

impl CommunicationMonitor {
    /// è®°å½•æ’ä»¶è°ƒç”¨
    pub fn record_plugin_call(
        &self,
        from: &PluginId,
        to: &PluginId,
        latency: Duration,
        success: bool
    ) {
        let key = (from.clone(), to.clone());
        
        self.call_stats.entry(key).and_modify(|stats| {
            stats.total_calls += 1;
            if success {
                stats.successful_calls += 1;
            } else {
                stats.failed_calls += 1;
            }
            
            // æ›´æ–°å»¶è¿Ÿç»Ÿè®¡
            let total_latency = stats.average_latency * stats.total_calls as u32 + latency;
            stats.average_latency = total_latency / stats.total_calls as u32;
            stats.max_latency = stats.max_latency.max(latency);
            stats.last_call_time = chrono::Utc::now().timestamp();
        }).or_insert_with(|| CallStatistics {
            total_calls: 1,
            successful_calls: if success { 1 } else { 0 },
            failed_calls: if success { 0 } else { 1 },
            average_latency: latency,
            max_latency: latency,
            last_call_time: chrono::Utc::now().timestamp(),
        });
    }
    
    /// ç”Ÿæˆé€šä¿¡æ€§èƒ½æŠ¥å‘Š
    pub fn generate_performance_report(&self) -> CommunicationPerformanceReport {
        let call_stats = self.call_stats.iter()
            .map(|entry| (entry.key().clone(), entry.value().clone()))
            .collect();
        
        let event_stats = self.event_stats.iter()
            .map(|entry| (entry.key().clone(), entry.value().clone()))
            .collect();
        
        let message_stats = self.message_stats.iter()
            .map(|entry| (entry.key().clone(), entry.value().clone()))
            .collect();
        
        CommunicationPerformanceReport {
            call_statistics: call_stats,
            event_statistics: event_stats,
            message_statistics: message_stats,
            generated_at: chrono::Utc::now().timestamp(),
        }
    }
}
```

## 7. æ€»ç»“

è¿™ä¸ªè·¨æ’ä»¶é€šä¿¡ä¸ä¾èµ–ç®¡ç†æœºåˆ¶æä¾›äº†ï¼š

### 7.1 å››ç§é€šä¿¡æ¨¡å¼å¯¹æ¯”

| é€šä¿¡æ¨¡å¼ | ç±»å‹å®‰å…¨ | æ€§èƒ½ | è§£è€¦åº¦ | é€‚ç”¨åœºæ™¯ |
|---------|---------|------|--------|---------|
| **ç›´æ¥ä¾èµ–è°ƒç”¨** | âœ… ç¼–è¯‘æ—¶ | ğŸš€ æœ€é«˜ | âš ï¸ ç´§è€¦åˆ | åŒæ­¥æ“ä½œã€å…³é”®è·¯å¾„ |
| **äº‹ä»¶å‘å¸ƒè®¢é˜…** | âœ… ç¼–è¯‘æ—¶ | âš¡ é«˜ | âœ… æ¾è€¦åˆ | å¼‚æ­¥é€šçŸ¥ã€ä¸€å¯¹å¤š |
| **æ¶ˆæ¯ä¼ é€’** | âš ï¸ è¿è¡Œæ—¶ | ğŸ“Š ä¸­ç­‰ | âœ… æ¾è€¦åˆ | è·¨æ—¶é—´åè°ƒã€æŒä¹…åŒ– |
| **å…±äº«çŠ¶æ€è®¿é—®** | âœ… ç¼–è¯‘æ—¶ | ğŸš€ è¯»ä¼˜åŒ– | âš ï¸ ä¸­ç­‰è€¦åˆ | é¢‘ç¹è¯»å–ã€ç¼“å­˜å‹å¥½ |

### 7.2 æ ¸å¿ƒä¼˜åŠ¿

1. **é›¶æˆæœ¬æŠ½è±¡** - ç¼–è¯‘æ—¶å¤šæ€ï¼Œè¿è¡Œæ—¶æ— é¢å¤–å¼€é”€
2. **ç±»å‹å®‰å…¨** - å¤§éƒ¨åˆ†é€šä¿¡åœ¨ç¼–è¯‘æ—¶ä¿è¯ç±»å‹æ­£ç¡®
3. **æ€§èƒ½ä¼˜åŒ–** - é’ˆå¯¹ä¸åŒåœºæ™¯çš„æ€§èƒ½ä¼˜åŒ–ç­–ç•¥
4. **è§£è€¦è®¾è®¡** - æ”¯æŒæ¾è€¦åˆçš„æ’ä»¶åä½œ
5. **ç›‘æ§å‹å¥½** - å…¨é¢çš„æ€§èƒ½ç›‘æ§å’Œè°ƒè¯•æ”¯æŒ

è¿™æ ·è®¾è®¡æ—¢ä¿è¯äº†Rustçš„é›¶æˆæœ¬æŠ½è±¡ä¼˜åŠ¿ï¼Œåˆä¸ºæ’ä»¶é—´çš„å„ç§åä½œåœºæ™¯æä¾›äº†åˆé€‚çš„é€šä¿¡æœºåˆ¶ã€‚